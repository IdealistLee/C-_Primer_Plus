# C-_Primer_plus

my study C++
记录学习C++_primer_plus过程的示例代码

# 第四章 复合类型

常见的复合类型：数组，字符串，结构，共用体，枚举

## 数组

储存多个相同类型的值。

`````c++
// typeName arrayName[arraySize]
int int_name[10];
int int_name1[10] = {1,2,3,4,5,6,7,8,9,10}; // =  is optional
std::cout << name1[1];
`````

## 字符串

一个方便好用的字符数组，智能识别和使用

```c++
sting name;

```



## 结构体与共用体

**结构体（struct）：**
每个成员都有自己独立的内存空间，结构体的总大小是所有成员大小之和（考虑对齐填充）。这意味着你可以同时访问所有成员，并且它们各自保存独立的数据。

**共用体（union）：**
共用体的所有成员共用同一块内存，内存大小等于其中最大成员的大小。一次只能正确存储和使用其中一个成员，因为写入一个成员会覆盖其他成员的值。

---

## 指针

指针指向的是一个地址，对指针解除引用就获得了指针指向的值。

`int* p = &a;` p和&a都代表指针，a和*p都代表地址上储存的值。

### 声明指针

```c++
int * p; //声明了一个指向int类型的指针，空格是可选的
int *p; //传统C语言写法，强调*p是是int类型的值
int* p; //C++写法，强调int* 是一种类型，指向int的指针。
int a = 5;
int* p = &a; //声明一个指向int类型的指针，并初始化指针。
double* p_d;//声明一个指double类型的指针
char* p_ch;//声明一个指向char类型的指针
```

> **Note**
>
> *在对指针进行解除引用之前(\*p),一定要将**指针初始化**为一个确定的，合适的地址。*
>
> ```c++
> int* p;
> p = &a;// 重要，不然就是野指针
> cout << *p;
> ```

### new和delete分配内存

`new`和`delete`配合可以进行动态内存分配。

```c++
int* p = new int;   // 分配内存
*p = 20;            // 赋值
delete p;           // 释放内存
p = nullptr;        // 避免悬空指针
```

- **内存泄漏**：忘记 `delete` 会导致内存无法回收。
- **重复释放**：多次 `delete` 同一指针会崩溃

> 使用new和delete的规则：
>
> - 不要使用delete释放不是new分配的内存
> - 不要使用delete释放同一内存两次
> - 如果使用new []为数组分配内存，应使用delete[]来释放
> - 如果使用new为实体分配内存，应使用delete(没有方括号)释放内存
> - 对空指针使用delete是安全的

### 指针、数组和指针算术

|   **特性**   |         **指针**          |           **数组名**           |
| :----------: | :-----------------------: | :----------------------------: |
|   **本质**   |    变量，存储内存地址     |   符号，代表数组首元素的地址   |
| **内存分配** |   可指向动态或静态内存    |    静态分配（如栈或全局区）    |
|   **类型**   | 单独变量类型（如 `int*`） | 隐式指针类型（如 `int(*)[5]`） |
| **可修改性** |    可重新指向其他地址     |     不可修改（是常量指针）     |

- **核心区别**：数组名是常量符号，携带类型和大小信息；指针是变量，仅存储地址。





